---
layout: page
location: pages/coding/tools/flutter/leaf
permalink: /pages/coding/tools/flutter/Bloc
---

## Contents of this page:

- []()
    - []()
    - []()
    - []()
- []()
    - []()
    - []()

## Testing blocs

### Verifying mocks in bloc tests

- Add a `verify` clause:

```dart
blocTest('Does a thing',
    build: () => MyBloc(),
    setUp: () {
        when(
            () => mockMyService.doThing(
                user.id!,
            ),
        ).thenAnswer((_) => Future.value());
    },
    act: (bloc) {
        bloc.add(Myevent(user: user,),);
    },
    expect: () => [
        const MyState(),
    ],
    verify: (_) {
        verify(
            () => mockMyService.doThing(
                user.id!,
            ),
        ).called(1);
    },
);
```

- More here on how to do it if you're not using the `blocTest` syntax: https://github.com/felangel/bloc/issues/157
    - In this case you'll use `expectLater` and `then`
    - There's an example of this kind of test [here](https://github.com/brianegan/flutter_architecture_samples/blob/41a033f6e67ec51bba2edf669cfcb857498db58c/frideos_library/test/stats_bloc_test.dart#L45), although it doesn't use the `then` syntax

### Troubleshooting "No method stub was called from within `when()`"

- Error when running test: "No method stub was called from within `when()`"
- This can happen if you accidentally used a real object instead of a mock object
- But it can also happen if there is a problem with your `when` clause
- It happened to me when I had the following code:

```dart
blocTest('Does a thing',
    build: () => MyBloc(),
    setUp: () {
        when(
            () => mockMyService.doThing(
                user.id!,
            ),
        ).thenAnswer((_) => Future.value());
    },
    act: (bloc) {
        bloc.add(Myevent(user: user,),);
    },
    expect: () => [
        const MyState(),
    ],
);
```

- The problem was that `user.id` was null, so it couldn't resolve `user.id!`
- I discovered this when I removed the `when` call altogether and just ran the code. In the code itself it was passing `user.id!` into `doThing`, and I got the error "Null check operator used on a null value"
- Presumably this error was also being generated by the bloc test code, but not being handled, so it just fell through to an error abhout problem,s with the `when` clause

### Testing widget code that uses a BlocListener

- Like this:

```dart
testWidgets('If bloc has UserReady state, redirect to thing',
      (WidgetTester tester) async {
        when(() => thingBloc.state).thenReturn(
          const ThingStateInitial(),
        );
        whenListen(
          thingBloc,
          Stream.fromIterable([
            const ThingStateInitial(), // previous state
            const ThingStateUserReady(), // current state
          ]),
        );

        await tester.pumpWidget(initWidget(authProvider));
        await tester.pumpAndSettle();

        expect(find.text(thingScreenTitle), findsOneWidget);
      });
```

- ...but you don’t actually need to pass prev + current state to `whenListen`. If you’re only interested in the new state, you can just pass that in. Otherwise the listener gets triggered twice, once for each state. 
- You only need to pass both states in if you have a `listenWhen` clause set up in your `BlocListener` and you are looking at both prev and current states to decide whether to act or not. 
- You can do this instead:

```dart
testWidgets('If bloc has UserReady state, redirect to thing',
      (WidgetTester tester) async {
        when(() => thingBloc.state).thenReturn(
          const ThingStateInitial(),
        );
        whenListen(
          thingBloc,
          Stream.fromIterable([const ThingStateUserReady()]),
        );

        await tester.pumpWidget(initWidget(authProvider));
        await tester.pumpAndSettle();

        expect(find.text(thingScreenTitle), findsOneWidget);
      });
```

## Troubleshooting

### Troubleshooting "Cannot add new events after calling close"

- We got this when we entered the same screen twice
- The error was thrown the second time we entered the screen, the first time the screen tried to fire an event for a bloc
- It turned out the problem was that we were using `GetIt.RegisterSingleton` instead of `GetIt.RegisterFactory` in `main.dart`
- We changed this...

```dart
  GetIt.I.registerSingleton<ThingBloc>(
    ThingBloc(),
  );
```

- ...to this:

```dart
  GetIt.I.registerFactory<ThingBloc>(
    () => ThingBloc(),
  );
```

- Relevant links:
    - Someone else with same problem: https://stackoverflow.com/a/78253377
    - Good explanation: https://github.com/felangel/bloc/issues/1734#issuecomment-694802121

### Troubleshooting error on emitter.dart line 114

- This manifests really oddly
- The code stops in the debugger on whatever the previous line of code was
- But if you add debug strings you'll see the code has got past that and into the bloc event handler
- You'll probably see that `emit` has been called
- Look at the stack trace and you'll see it errored in emitter.dart
- Currently it says this: "emit was called after an event handler completed normally.
    This is usually due to an unawaited future in an event handler.
    Please make sure to await all asynchronous operations with event handlers
    and use emit.isDone after asynchronous operations before calling emit() to
    ensure the event handler has not completed."
- The solution is to make sure your event handler has `await` on any calls to async methods
- In my case, I had an async helper method in my bloc code that was being called by an event handler without using `await` on the call to the helper.


