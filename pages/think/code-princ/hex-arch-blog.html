<hr />
<h2 id="layout-page-location-pagesthinkcode-princleaf-permalink-pagesthinkcode-princhexagonal-architecture-blog-post">layout: page location: pages/think/code-princ/leaf permalink: /pages/think/code-princ/Hexagonal-Architecture-Blog-Post</h2>
<p>(!!! NB: ALL IMAGES ARE SAVED IN SAME FOLDER AS THIS DOC (currently Dropbox\Writing - Current\Blog posts\LateRooms Blog Posts)) by @ClareSudbery)</p>
<p>Even though I helped create a piece of software which supposedly implemented hexagonal architecture, it wasn't until I'd written this blog post that I really felt I <em>got</em> it. Indeed, as a way of really cementing and confirming your knowledge on a subject, I’d highly recommend presenting what you think you know for the benefit of an audience that’s new to the topic.</p>
<p>!! NB !! This has now been copied into clare-wiki, and is being worked on there in md format.</p>
<p>What you'll get here is a description of a Currency service which I helped to write at LateRooms.Com (RIP), along with a discussion of how it exemplifies hexagonal architecture. But I'll also explain where it falls short. And, just for fun, you'll get some pancakes: Dan Portella (@dmportella) and I created a ClaresPancakes solution, which was designed as a purer example of hexagonal architecture.</p>
<p>So, what is hexagonal architecture? Here is a diagram:</p>
<p><img src="./483637338e860aaa982902ebae5022233de4adf1.png" alt="Diagram of ports and adapters" /></p>
<ul>
<li><strong>yellow</strong>: core logic</li>
<li><strong>light red</strong>: primary ports</li>
<li><strong>light blue</strong>: primary adapters</li>
<li><strong>dark red</strong>: secondary ports</li>
<li><strong>dark blue</strong>: secondary adapters</li>
</ul>
<p>It's all about ports and adapters. These are split into primary and secondary.</p>
<ul>
<li>The <strong>primary</strong> ports and adapters represent the way you interact with your users</li>
<li>The <strong>secondary</strong> ports and adapters represent the way you interact with any services you need.</li>
</ul>
<p>The ports are the interfaces, and the adapters represent the code which allows those interfaces to be utilised.</p>
<p>Examples will make this a bit more concrete:</p>
<ul>
<li>A <strong>primary port</strong> is a contract (aka interface) you share with the world. This is the behaviour you agree to provide, independent of implementation.</li>
<li>A <strong>primary adapter</strong> will use the behaviour available on a primary port (again, regardless of implementation detail), and serve it up to the world. For instance, this could be a controller which takes in user input from a UI and passes it onto your application.</li>
<li>A <strong>secondary port</strong> will also be an interface or contract. But this time, it is the contract which you are expecting to be fulfilled by a third party, for instance a database.</li>
<li>A <strong>secondary adapter</strong> will be an implementation of a secondary port. For instance, this may be a data access implementation which uses SQL.</li>
<li>The <strong>domain</strong> is the actual logic of your application. You want to be able to implement this independently of either UI or third party services.</li>
<li>!! Note that whereas <strong>secondary adapters</strong> are implementations of interfaces, <strong>primary adapters</strong> are <em>clients</em> of interfaces. The implementation of the primary ports will happen within the domain.</li>
</ul>
<p>There's a good reason the same terms, "ports" and "adapters", are used for both clients and services - in fact, this is really the point of the model: The idea is that your core business logic should remain the same no matter what your front end looks like, <em>and</em> no matter how any third-party services are implemented. Clients and services are both "outside" as far as your domain is concerned, and therefore they can be modelled using the same concepts.</p>
<p>The aim is to "allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases" (from <a href="http://alistair.cockburn.us/Hexagonal+architecture">Alistair Cockburn's article about hexagonal architecture</a>). I can also recommend this <a href="http://www.dossier-andreas.net/software_architecture/ports_and_adapters.html">Garfixia Software article</a>.</p>
<h4 id="hotel-distributions-currency-service">Hotel Distribution's Currency Service</h4>
<p>Our Currency service effectively has a hexagonal architecture. We currently have two related solutions in our code base (available internally to LateRooms as git repos in the Hotel Distributions project):</p>
<ul>
<li><strong>Currency.SDK</strong></li>
<li><strong>Currency.API</strong></li>
</ul>
<p>The SDK is published internally as a NuGet package, and contains all the logic. The API is currently a Nancy app, which has its own instance of the Currency.SDK NuGet package. It is available (internally) on our network as a RESTful endpoint.</p>
<p>Here is an overview of the shape of the Currency.SDK solution:</p>
<p><img src="./557bb6e0d8249b84961e555c48fc48c6f27af3f8.jpg" alt="Currency.SDK" /></p>
<h4 id="currencysdk---primary-ports">Currency.SDK - Primary Ports</h4>
<p>There are two primary ports:</p>
<ul>
<li><strong>ICurrencyConverter</strong> - allows clients to convert monetary values from one currency to another</li>
<li><strong>ISymbolFetcher</strong> - clients use this to fetch currency symbols (eg "£")</li>
</ul>
<p>Both of these ports are implemented in the domain (Currency.Engine).</p>
<h4 id="currencysdk---secondary-ports">Currency.SDK - Secondary Ports</h4>
<p>There are several secondary ports:</p>
<ul>
<li>ICurrencyRepo</li>
<li>IDataCache</li>
<li>IUdpErrorLogger</li>
<li>ILogStashConfig</li>
</ul>
<p>Note that at the moment, most of our ports live in the Currency.Contracts project (see "Refactoring" below for more discussion on this).</p>
<h4 id="currencysdk---secondary-adapters">Currency.SDK - Secondary Adapters</h4>
<p>Each secondary port has its own secondary adapter - these are all implementations of the relevant interfaces. For instance, <strong>ICurrencyRepo</strong> is implemented by <strong>SqlCurrencyRepo</strong>, in the <strong>Currency.DataAccess.SQL</strong> project.</p>
<h4 id="currencysdk---primary-adapters">Currency.SDK - Primary Adapters</h4>
<p>We effectively have two primary adapters:</p>
<ul>
<li>A Nancy module - <strong>ConverterModule</strong> - in Currency.API. This takes UI from the REST endpoint, and passes it through to the Currency.SDK instance.</li>
<li>Another Nancy module - <strong>SymbolModule</strong> - in Currency.API (works in the same way).</li>
</ul>
<p>Note that if the SDK were accessible directly as a REST endpoint, then we could also have another primary adapter via SOAP UI, which would take the form of acceptance tests.</p>
<h4 id="currencysdk---dependency-injection">Currency.SDK - Dependency Injection</h4>
<p>Our architecture was not originally properly hexagonal. Originally the Nancy API and the SDK lived in the same solution, and all the dependency injection was handled using the TinyIoC which comes for free with Nancy. This meant that we got away with giving the API project sight of all the interfaces <em>and</em> their implementations. It also meant that we didn't notice that our interfaces lived in the same project as our domain logic.</p>
<p>As soon as we tried to split the API and the SDK into different solutions, this stopped working because cyclic dependencies were created when we tried to inject the SQL Data Access implementation.</p>
<p>What we have now is a separate project for interfaces, and we also supply our NuGet clients with a factory (<strong>CurrencyObjectFactory</strong>, in <strong>Currency.Services</strong>). They can use this to instantiate whatever they need, and it handles all the dependency injection for them (for instance it decides which data-access implementation to use, which isn't something they should care about).</p>
<h4 id="currencysdk---refactoring">Currency.SDK - Refactoring</h4>
<p>It's interesting that in the process of writing this post, I've realised there is some muddiness in the Currency.SDK solution which means that its hexagonal architecture isn't immediately apparent:</p>
<ul>
<li>The <strong>Currency.Contracts</strong> project should be the resting place for secondary ports. But there is at least one interface in here (<strong>IErrorObserver</strong>) which is arguably not a secondary port at all, and should be internal to the domain (the <strong>Currency.Engine</strong> project).</li>
<li>There are several secondary adapters (eg caching and logging) which live in <strong>Currency.Engine</strong> (the domain), rather than their own separate projects.</li>
<li>There is currently a primary port (<strong>ISymbolFetcher</strong>) which is in <strong>Currency.Engine</strong>, rather than <strong>Currency.Contracts</strong>.</li>
<li>The other primary port (<strong>ICurrencyConverter</strong>) is in <strong>Currency.Contracts</strong> with all the secondary ports. It's therefore not clear that <strong>ICurrencyConverter</strong> is any different from all the other interfaces. I'd like to move it - and <strong>ISymbolFetcher</strong> - into a separate project which contains only primary ports. Or maybe they should live with the object factory, in <strong>Currency.Service</strong>?</li>
</ul>
<p>On the back of this blog post, I now have a list of things I'd like to refactor. <strong>But</strong> it's worth noting that the Currency service is a small and simple piece of code. We already had a conversation, for instance, about the fact that many of the secondary ports (for instance, caching and error logging) are implemented by secondary adapters which live within the domain (the <strong>Currency.Engine</strong> project. This is not technically correct, but we decided that it would be over-engineering if we were to create a separate project for each secondary adapter. Feel free to disagree. :)</p>
<p>Aside: The great thing about writing blog posts, or writing documentation, or even just writing notes about what you're doing: It forces you to think about what you're doing, and often allows you to spot weaknesses in your code. The same applies to explaining what you're doing out loud to another person - one of the many benefits of pair coding.</p>
<h4 id="clares-pancakes">Clare's Pancakes</h4>
<p>There is a purer hexagonal example in the <a href="https://github.com/claresudbery/ClaresPancakes">Clare's Pancakes git repo</a> (publicly available).</p>
<p>Hopefully the project structure, once you have some understanding of how hexagonal architecture is supposed to work, is reasonably self-evident. It looks like this:</p>
<p><span class="image">Clare's Pancakes</span></p>
<h4 id="clares-pancakes---primary-ports">Clare's Pancakes - Primary Ports</h4>
<p>There is just one primary port, which represents the contract provided by a pancake maker (<strong>IPancakeMaker</strong>). It currently has just one method: <strong>GiveMePancakes</strong>.</p>
<p>Note that the <strong>Pancake</strong> model is also defined here, as it is needs to be surfaced to primary users.</p>
<h4 id="clares-pancakes---primary-adapters">Clare's Pancakes - Primary Adapters</h4>
<p>There are two primary adapters, both handily located in a primary adapters folder:</p>
<ul>
<li><strong>Pancakes.REST.API</strong> - an API with a module which allows you to "get" pancakes. It uses a pancake maker provided by <strong>PancakeMakerFactory.CreatePancakeMaker</strong></li>
<li><strong>Pancakes.Domain.Acceptance.Tests</strong> - this, like the API, takes a pancake maker provided by the factory. It checks that it gives us pancakes when we ask for them. :)</li>
</ul>
<h4 id="clares-pancakes---secondary-ports">Clare's Pancakes - Secondary Ports</h4>
<ul>
<li><strong>IPancakeMixDispenser</strong> - The pancake maker needs a dispenser to give it some pancake mix.</li>
<li><strong>IPancakeOven</strong> - We want to cook those pancakes.</li>
<li><strong>PancakeMix</strong> - this model is defined here, as it is not surfaced to primary users.</li>
</ul>
<h4 id="clares-pancakes---secondary-adapters">Clare's Pancakes - Secondary Adapters</h4>
<ul>
<li><strong>Pancakes.MixDispenser.Breville</strong> There is currently only one implementation of IPancakeMixDispenser.</li>
<li><strong>Pancakes.Oven.Bosch</strong> This is one implementation of IPancakeOven.</li>
<li><strong>Pancakes.Oven.Hotpoint</strong> This is another implementation of IPancakeOven.</li>
</ul>
<h4 id="clares-pancakes---dependency-injection">Clare's Pancakes - Dependency Injection</h4>
<p>If you want a pancake maker, you don't have to care what mix dispenser or what oven it uses. Just new yourself up a <strong>PancakeMakerFactory</strong> and call its <strong>CreatePancakeMaker</strong> method. It will make all the decisions about oven, etc.</p>
<h4 id="clares-pancakes---domain">Clare's Pancakes - Domain</h4>
<p><strong>Pancakes.Domain</strong> uses <strong>PancakeMaker2000</strong> to implement a pancake maker for you.</p>
<p>Of course, in reality you wouldn't name your projects and folders things like "primary adapters" and the like - you'd give them names that were more meaningful to your domain. But I've used these names here to make everything explicit.</p>
<p>I get it now. Hopefully you do too. :)</p>
<p>@ClareSudbery</p>
<p>(Clare also blogs here: <a href="https://medium.com/@claresudbery/blog-posts-d14731e4803d">A Woman in Technology</a>).</p>
